{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Petra","text":"<p>Putting it simply, Petra is a private registry for Terraform modules for GCP. </p>"},{"location":"#why-we-made-it","title":"Why we made it ?","text":"<p>Petra was created to solve multiple problems encountered by most people that are using Terraform :</p> <ul> <li> <p>Internal Module Sharing : Organizations often have their own set of standardized infrastructure modules that are used across multiple projects. With a private registry, these modules can be centrally stored and easily shared among different teams or projects within the organization. It ensures consistency, promotes reuse, and helps maintain best practices across infrastructure deployments.</p> </li> <li> <p>Customization and Version Control : A private registry allows organizations to customize and modify existing Terraform modules to fit their specific needs without impacting the original module source. This is particularly useful when making project-specific modifications or incorporating organization-specific configurations. Having version control in the private registry enables tracking and management of these customizations.</p> </li> <li> <p>Offline Environments : In certain scenarios, infrastructure deployments may be required in offline or air-gapped environments where internet access is limited or restricted. With a private registry, organizations can create a local copy of the registry and make it available within the restricted environment. This allows for self-contained infrastructure provisioning without relying on external networks.</p> </li> <li> <p>Decorrelate Git repositories from Terraform modules: People in need of a private terraform registry often try to use Terraform Cloud for their private terraform registry needs but find the limitation of having to create a git repository per module to be too cumbersome. </p> </li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>The server can be deployed using it's docker image on Kubernetes or even Cloud Run. All the server needs is rights to a Google Cloud Storage Bucket created to store the modules.</p> <p>You can use your terraform modules like so :</p> <p></p> <p>The petra server endpoint has to support HTTPs or terraform won't allow you to init the module.</p> <p><code>petractl</code> needs a petra-config.yaml file to be present in the directories of the related terraform modules. You are then able to push modules directly to the bucket using the command <code>petractl push -b $MY_BUCKET .</code> </p> <p></p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#setup-the-server","title":"Setup the server","text":""},{"location":"quickstart/#1-create-a-cloud-storage-bucket-and-service-account","title":"1. Create a Cloud Storage bucket and service account.","text":"<pre><code>gcloud storage buckets create gs://$BUCKET_NAME --project=PROJECT_ID --location=$BUCKET_LOCATION --uniform-bucket-level-access\n</code></pre> <p><code>$BUCKET_NAME</code> needs to be a unique name</p> <p>Create a Service Account for the Petra server with the <code>Storage Object Admin</code> role on the <code>$BUCKET_NAME</code> bucket and <code>Service Account Token Creator</code> on the project if you want the server to run with the <code>SIGNED_URL</code> option.</p> <pre><code>gcloud iam service-accounts create $SA_NAME\n\n# If you are not using the SIGNED_URL option, you will need to give each serviceAccount/user using the terraform modules read rights on the bucket. \ngcloud storage buckets add-iam-policy-binding gs://$BUCKET_NAME \\\n--member=serviceAccount:$SA_NAME@$PROJECT_ID.iam.gserviceaccount.com \\\n--role=roles/storage.objectAdmin\n\n# (optional) If you want to run Petra server in the SIGNED_URL mode.\ngcloud projects add-iam-policy-binding $PROJECT_ID \\\n--member=\"serviceAccount:SA_NAME@PROJECT_ID.iam.gserviceaccount.com\" \\\n--role=\"roles/iam.serviceAccountTokenCreator\"\n</code></pre> <p>To push modules to the <code>$BUCKET_NAME</code> bucket, the serviceAccount/user running petractl will need write access to the bucket.</p>"},{"location":"quickstart/#2-build-deploy-to-cloud-run","title":"2. Build &amp; Deploy to Cloud Run","text":"<p>Since <code>ghcr.io</code> images cannot be used in Cloud Run, you will have to host the docker image on either Google's Artifact Registry or Container Registry <code>(deprecated)</code>, or DockerHub.  With Artifact Registry, your <code>$IMAGE_PATH</code> will look like <code>[$REGION-]docker.pkg.dev/$PROJECT_ID/$REGISTRY_NAME/petra:$TAG</code></p> Rebuild and push with Cloud Build cloudbuild.yaml<pre><code>steps:\n# Build the container image\n- name: 'gcr.io/cloud-builders/docker'\nargs: ['build', '-t', '$IMAGE_PATH', '-f',  'Dockerfile.manual', '.']\n# Push the container image to Container Registry\n- name: 'gcr.io/cloud-builders/docker'\nargs: ['push', '$IMAGE_PATH']\n# Deploy container image to Cloud Run\n- name: 'gcr.io/cloud-builders/gcloud'\nentrypoint: gcloud\nargs: ['run', 'deploy', 'petra', '--image', '$IMAGE_PATH', '--platform', 'managed', '--region', '$REGION', '--allow-unauthenticated' '--set-env-vars', 'GCS_BUCKET=$BUCKET']\nimages:\n-  $IMAGE_PATH\n</code></pre> <p>Here, the created Cloud Run service does not require any authentication as it is not supported by Terraform. Access is managed by directly updating bucket's IAM. The Cloud Run is deployed with all traffic allowed but you can also restrict to internal traffic only, but in this case, you'll have to make sure that a HTTPs endpoint is exposed or Terraform won't be able to pull the modules.</p>"},{"location":"quickstart/#pushing-modules","title":"Pushing modules","text":""},{"location":"quickstart/#1-download-petractl","title":"1. Download Petractl","text":"<p>Go to the latest release page and download one of the following files, depending on you OS / CPU architecture:</p> MacOSLinux <ul> <li>petra_x.x.x_darwin_amd64.tar.gz (Intel)</li> <li>petra_x.x.x_darwin_arm64.tar.gz (Apple Silicon)</li> </ul> <ul> <li>petra_0.4.1_linux_amd64.tar.gz (x86_64)</li> <li>petra_0.4.1_linux_arm64.tar.gz (arm64)</li> </ul>"},{"location":"quickstart/#2-create-a-petra-configyaml-file-for-your-module","title":"2. Create a petra-config.yaml file for your module","text":"petra-config.yaml<pre><code>namespace: production\nname: my-module\nprovider: google\nversion: 1.0.3\n</code></pre> <p>The file must be located at the root of your module</p>"},{"location":"quickstart/#3-push-the-module","title":"3. Push the module","text":"<p>Make sure that you have the permission to write new files on the bucket <code>$BUCKET_NAME</code>. </p> <pre><code>petractl push --bucket $BUCKET_NAME ./path/to/module\n</code></pre>"},{"location":"quickstart/#use-your-modules-in-terraform","title":"Use your modules in Terraform","text":"<p>In order to use the modules, make sure that the user or Service Account that will be running the <code>terraform init</code> command has access to the petra server and read access permission on the bucket <code>$BUCKET_NAME</code> (or that the <code>SIGNED_URL</code> option is enabled).</p> <p>Here is an example of Terraform code that uses a petra hosted module:</p> main.tf<pre><code>module \"mod1\" {\nsource = \"petra.example.com/production/my-module/google\"\nversion = \"1.0.3\"\n}\n</code></pre> <p><code>petra.example.com</code> has to support HTTPS or Terraform's init command won't work</p>"}]}